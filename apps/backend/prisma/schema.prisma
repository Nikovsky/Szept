// ========== GENERATOR & DATASOURCE ==========
generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserStatus {
  ONLINE
  BUSY
  OFFLINE
}

enum SecurityEventType {
  LOGIN
  REFRESH
  LOGOUT
  REVOKE
  REPLAY_DETECTED
  SOCKET_CONNECT
  SOCKET_DISCONNECT
  MESSAGE_SEND
}

// ========== MODELE DANYCH ==========
// Użytkownik systemu czatu
model User {
  id          String     @id @default(uuid())
  email       String     @unique
  password    String
  displayName String     @unique
  status      UserStatus @default(OFFLINE)
  avatarUrl   String?
  lastSeen    DateTime?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  // relacje
  messages            Message[]            @relation("MessagesSent")
  chats               UserOnChat[]
  readMessages        MessageRead[]
  notifications       Notification[]
  callsMade           Call[]               @relation("CallsMade")
  callsReceived       Call[]               @relation("CallsReceived")
  refreshSessions     RefreshSession[]
  passwordResetTokens PasswordResetToken[]
  securityEvents      SecurityEvent[]
  devices             Device[]
}

// Czaty 1:1 lub grupowe
model Chat {
  id        String   @id @default(uuid())
  name      String?
  isGroup   Boolean  @default(false)
  createdAt DateTime @default(now())

  // relacje
  members  UserOnChat[]
  messages Message[]
  calls    Call[]
}

// Relacja wielu do wielu między użytkownikami a czatami
model UserOnChat {
  userId   String
  chatId   String
  role     String   @default("member") // member | admin
  joinedAt DateTime @default(now())

  // relacje
  user User @relation(fields: [userId], references: [id])
  chat Chat @relation(fields: [chatId], references: [id])

  @@id([userId, chatId])
}

// --- E2EE ---
model Device {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name       String
  platform   String // web | ios | android | desktop
  createdAt  DateTime @default(now())
  lastSeenAt DateTime @default(now())

  idKeyPub    Bytes
  signKeyPub  Bytes
  fingerprint String  @unique
  isVerified  Boolean @default(false)

  signedPreKeys  SignedPreKey[]
  oneTimePreKeys OneTimePreKey[]
  messages       Message[]       @relation("MessagesFromDevice")
  Message        Message[]
}

model SignedPreKey {
  id        String   @id @default(cuid())
  deviceId  String
  device    Device   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  keyId     Int
  pub       Bytes
  signature Bytes
  createdAt DateTime @default(now())
  isCurrent Boolean  @default(true)

  @@unique([deviceId, keyId])
}

model OneTimePreKey {
  id         String    @id @default(cuid())
  deviceId   String
  device     Device    @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  keyId      Int
  pub        Bytes
  consumedAt DateTime?
  createdAt  DateTime  @default(now())

  @@unique([deviceId, keyId])
  @@index([deviceId, consumedAt])
}

// Wiadomości (tekst, obraz, głosówka)
model Message {
  id             String        @id @default(uuid())
  chatId         String
  senderId       String
  senderDeviceId String
  encType        String
  ciphertext     Bytes
  nonce          Bytes
  ad             Bytes?
  ratchetCounter Int?
  keyId          Int?
  status         String        @default("sent")
  createdAt      DateTime      @default(now())
  deliveredAt    DateTime?
  readReceipts   MessageRead[]

  // relacje
  chat         Chat    @relation(fields: [chatId], references: [id], onDelete: Cascade)
  sender       User    @relation("MessagesSent", fields: [senderId], references: [id])
  senderDevice Device  @relation("MessagesFromDevice", fields: [senderDeviceId], references: [id])
  Device       Device? @relation(fields: [deviceId], references: [id])
  deviceId     String?

  @@index([chatId, createdAt])
  @@index([senderId, createdAt])
}

// Kto i kiedy odczytał wiadomość
model MessageRead {
  userId    String
  messageId String
  readAt    DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id])
  message Message @relation(fields: [messageId], references: [id])

  @@id([userId, messageId])
}

// Historia rozmów głosowych (WebRTC)
model Call {
  id        String    @id @default(uuid())
  chatId    String
  callerId  String
  calleeId  String
  startedAt DateTime  @default(now())
  endedAt   DateTime?

  duration Int?
  status   String @default("completed") // completed | missed | ongoing

  chat   Chat @relation(fields: [chatId], references: [id])
  caller User @relation("CallsMade", fields: [callerId], references: [id])
  callee User @relation("CallsReceived", fields: [calleeId], references: [id])
}

// Powiadomienia systemowe (np. zaproszenia)
model Notification {
  id        String   @id @default(uuid())
  userId    String
  type      String   @default("system") // system | invtie
  message   String
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
}

// Sesja odświeżania tokenów
model RefreshSession {
  id           String    @id @default(uuid())
  userId       String
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  rtHash       String
  familyId     String    @default(uuid())
  createdAt    DateTime  @default(now())
  expiresAt    DateTime
  revokedAt    DateTime?
  replacedBy   String?
  ipHash       String?
  uaHash       String?
  lastUsedAt   DateTime?
  refreshCount Int

  @@index([userId, revokedAt, createdAt], map: "idx_refresh_active")
  @@index([familyId])
  @@index([expiresAt])
}

// Token resetu hasła
model PasswordResetToken {
  id        String    @id @default(uuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash String
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([userId])
  @@index([expiresAt])
}

// Rejestr zdarzeń bezpieczeństwa (audit trail)
model SecurityEvent {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      String // LOGIN | REFRESH | LOGOUT | REVOKE | REPLAY_DETECTED
  ip        String? // skrócony IP lub hash
  ua        String? // user-agent lub hash
  details   String? // JSON string (dodatkowe dane)
  createdAt DateTime @default(now())

  @@index([userId, createdAt], map: "idx_securityevent_user_date")
}
